% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/nint.R
\name{nint_integrateNCube}
\alias{nint_integrateNCube}
\alias{nint_integrateNCube_SparseGrid}
\alias{nint_integrateNCube_cubature}
\alias{nint_integrateNCube_integrate}
\title{Integrate N Cube}
\usage{
nint_integrateNCube(f, lowerLimit, upperLimit, ...)

nint_integrateNCube_integrate(integrate)

nint_integrateNCube_cubature(adaptIntegrate)

nint_integrateNCube_SparseGrid(createIntegrationGrid)
}
\arguments{
\item{integrate}{\code{function(f, lowerLimit, upperLimit, ...)} which calls \code{stats::integrate}.}

\item{adaptIntegrate}{\code{function(f, lowerLimit, upperLimit, ...)} which calls \code{cubature::adaptIntegrate}.}

\item{createIntegrationGrid}{\code{function(dimension)} which calls \code{SparseGrid::createIntegrationGrid}.}

\item{f}{the scalar-valued function (integrand) to be integrated.}

\item{lowerLimit}{the lower limits of integration.}

\item{upperLimit}{the upper limits of integration.}

\item{...}{other arguments passed to \code{f}.}
}
\value{
\code{nint_integrateNCube} returns a single numeric.
}
\description{
Interface to the integration over interval dimensions.
}
\details{
\code{nint_integrateNCube} is a reference to the function that \code{nint_integrate} calls with exactly these arguments to integrate over interval dimensions.
See examples below on how to replace it with a different function.

\code{nint_integrateNCube_integrate} uses \code{integrate} recursively.
Downside: number of function evaluations is \code{(subdivisions * 21) ** N}.
This is the default because no package is required.
However, you most likely want to consider different solutions.

\code{nint_integrateNCube_cubature} is a trivial wrapper for \code{cubature::adaptIntegrate}.

\code{nint_integrateNCube_SparseGrid} is an almost trivial wrapper for \code{SparseGrid::createIntegrationGrid}.
It scales the grid to the integration region.
}
\examples{
library(docopulae)

## integrate with defaults
nint_integrate(sin, nint_space(nint_intvDim(0, 2*pi)))

## replace nint_integrateNCube
f = function(f, lowerLimit, upperLimit, ...) {
    integrate(f, lowerLimit, upperLimit, ..., subdivisions=2)
}
f = nint_integrateNCube_integrate(f)

unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', f, envir=environment(nint_integrate))

## integrate with replacement
nint_integrate(sin, nint_space(nint_intvDim(0, 2*pi))) # no difference here

## replace nint_integrateNCube
f = function(f, lowerLimit, upperLimit, ...) {
    r = cubature::adaptIntegrate(f, lowerLimit, upperLimit, ..., maxEval=1e3)
    return(r$integral)
}

unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', f, envir=environment(nint_integrate))

## integrate with replacement
# should print "Loading required package: cubature"
nint_integrate(sin, nint_space(nint_intvDim(0, 2*pi)))

## replace nint_integrateNCube
f = function(dimension) {
    SparseGrid::createIntegrationGrid('GQU', dimension, 7)
}
f = nint_integrateNCube_SparseGrid(f)
unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', f, envir=environment(nint_integrate))

## integrate with replacement
# should print "Loading required package: SparseGrid"
nint_integrate(sin, nint_space(nint_intvDim(0, 2*pi)))
}
\seealso{
\code{\link{nint_integrate}}

\code{\link{integrateA}}, \code{\link[stats]{integrate}} in \pkg{stats}

\code{\link[cubature]{adaptIntegrate}} in package \pkg{cubature}

\code{\link[SparseGrid]{createIntegrationGrid}} in package \pkg{SparseGrid}
}

