% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/nint.R
\name{nint_transform}
\alias{nint_transform}
\title{Transform Integral}
\usage{
nint_transform(f, space, dIdcs, trans, infZero = 0)
}
\arguments{
\item{f}{\code{function(x, ...)}.}

\item{space}{some space.}

\item{dIdcs}{an integer vector of indices, the dimensions to transform.}

\item{trans}{either the name of some builtin transformation or \code{list(g=function(x), gij=function(y))} where \code{y = g(x)} and \code{gij} evaluates to the column matrix of \code{gi(y) = x} and its first derivative with respect to \code{y}.}

\item{infZero}{the value to return if the jacobian is infinite and \code{f} returns \code{0}.}
}
\value{
\code{nint_transform} returns a named list containing the transformed function and space.
}
\description{
\code{nint_transform} applies monotonic continous transformations.
A common use case is to transform infinite intervals to finite ones.
}
\details{
If the transformation is vector valued, that is \code{y = c(y1, ..., yn) = g(c(x1, ..., xn))}, then each component of \code{y} shall exclusively depend on the corresponding component of \code{x}.
An incorrect expression for this would be: \code{y[i] = g[i](x[i])}.

Builtins: \itemize{
\item tan: \code{y = atan(x)}
\item ratio: \code{y = x/abs(x + sign(x))} with \code{sign(0) == 1}
}
}
\examples{
library(docopulae)

f = sin
s = nint_space(nint_intvDim(-2.11, 1.76))
nint_integrate(f, s)

tt = nint_transform(f, s, 1, 'tan')
tt$space
nint_integrate(tt$f, tt$space)

tt = nint_transform(f, s, 1, 'ratio')
tt$space
nint_integrate(tt$f, tt$space)

tt = nint_transform(f, s, 1, list(g=pnorm, gij=function(x) { t1 = qnorm(x); cbind(t1, 1/dnorm(t1))}))
tt$space
nint_integrate(tt$f, tt$space)


f = function(x) prod(1/(1 + x**2))
s = nint_space(nint_intvDim(-1, Inf),
               nint_intvDim(-Inf, Inf))
s

nint_integrate(f, s) # stats::integrate takes care of Inf limits

tt = nint_transform(f, s, 1:2, 'tan')
tt$space
nint_integrate(tt$f, tt$space)

tt = nint_transform(f, s, 1:2, 'ratio')
tt$space
nint_integrate(tt$f, tt$space)

tt = nint_transform(f, s, 1, list(g=pnorm, gij=function(x) { t1 = qnorm(x); cbind(t1, 1/dnorm(t1))}))
tt$space
# won't terminate. I guess the transformation is too steep
#nint_integrate(tt$f, tt$space)

}
\seealso{
\code{\link{nint_space}}, \code{\link{nint_integrate}}, \code{\link{nint_intvDim}}
}

