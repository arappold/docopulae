% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/main.R
\name{numDerivLogf}
\alias{numDeriv2Logf}
\alias{numDerivLogf}
\title{Build Derivative Function for Log f}
\usage{
numDerivLogf(f, logZero = .Machine$double.xmin,
  logInf = .Machine$double.xmax/2, method = "Richardson",
  method.args = list(eps = 1e-04, d = 0.1, zero.tol =
  sqrt(.Machine$double.eps/7e-07), r = 4, v = 2, show.details = F))

numDeriv2Logf(f, logZero = .Machine$double.xmin,
  logInf = .Machine$double.xmax/2, method = "Richardson",
  method.args = list(eps = 1e-04, d = 0.1, zero.tol =
  sqrt(.Machine$double.eps/7e-07), r = 4, v = 2, show.details = F))
}
\arguments{
\item{f}{\code{function(y, theta, ...)}, where \code{theta} is a list of parameters.
A joint probability density function.}

\item{logZero}{the value \code{log(f)} should return if \code{f} evaluates to \code{0}.}

\item{logInf}{the value \code{log(f)} should return if \code{f} evaluates to \code{Inf}.}

\item{method}{see \pkg{numDeriv}}

\item{method.args}{see \pkg{numDeriv}}
}
\value{
\code{numDerivLogf} returns \code{function(y, theta, i, ...)} which evaluates to the first derivative of \code{log(f(y, theta, ...))} with respect to \code{theta[[i]]}.

\code{numDeriv2Logf} returns \code{function(y, theta, i, j, ...)} which evaluates to the second derivative of \code{log(f(y, theta, ...))} with respect to \code{theta[[i]]} and \code{theta[[j]]}.
}
\description{
Builds a function that evaluates to the first/second derivative of \code{log(f(y, theta, ...))} with respect to \code{theta[[i]]}/\code{theta[[i]]} and \code{theta[[j]]}.
}
\details{
\pkg{numDeriv} produces \code{NaN}s if the log evaluates to (negative) \code{Inf} so you may want to specify \code{logZero} and \code{logInf}.
}
\examples{
library(copula)

## build f
margins = function(y, theta) {
    mu = c(theta$mu1, theta$mu2)
    cbind(dnorm(y, mu, 1), pnorm(y, mu, 1))
}
C = copula::frankCopula()

f = buildf(margins, C, 'alpha')
f

theta = list(alpha=-2, mu1=3, mu2=-8)
y = c(3, -8)
f(y, theta)

## build first derivative
dlogf = numDerivLogf(f)
dlogf

dlogf(y, theta, 'alpha')
n = names(theta)
sapply(n, function(i) dlogf(y, theta, i))

## build second derivative
d2logf = numDeriv2Logf(f)
d2logf

d2logf(y, theta, 'alpha', 'mu1')
m = outer(n, n, function(a, b) apply(cbind(a, b), 1,
    function(x) d2logf(y, theta, x[1], x[2])))
dimnames(m) = list(n, n)
m
}
\seealso{
\pkg{numDeriv}, \code{\link{buildf}}, \code{\link{DerivLogf}}, \code{\link{fisherI}}
}

