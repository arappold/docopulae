% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/main.R
\name{DerivLogf}
\alias{Deriv2Logf}
\alias{DerivLogf}
\title{Build Derivative Function for Log f}
\usage{
DerivLogf(f, names, map = NULL, yMap = NULL, thetaMap = NULL)

Deriv2Logf(f, names, map = NULL, yMap = NULL, thetaMap = NULL)
}
\arguments{
\item{f}{an expression, a joint probability density.}

\item{names}{a character vector of variable names.}

\item{map}{a named list of character strings defining left assignments (\code{a="b"} => \code{a <- b}).}

\item{yMap}{like \code{map} with \code{a=b} resolving to \code{a <- y[b]}.}

\item{thetaMap}{like \code{map} with \code{a=b} resolving to \code{a <- theta[[b]]}.}
}
\value{
\code{DerivLogf} returns \code{function(y, theta, i, ...)} where \code{theta} is a list of parameters.
It evaluates to the first derivative of \code{log(f)} with respect to variable \code{i}.
Additionally the attribute \code{"d"} contains the list of sub functions.

\code{Deriv2Logf} returns \code{function(y, theta, i, j, ...)} where \code{theta} is a list of parameters.
It evaluates to the second derivative of \code{log(f)} with respect to the variables \code{i} and \code{j}.
Additionally the attribute \code{"d2"} contains the list of sub functions.
}
\description{
Builds a function that evaluates to the first/second derivative of \code{log(f)} with respect to a predefined set of variables/variable combinations.
}
\details{
While \code{numDerivLogf} relies on \pkg{numDeriv} and therefore uses finite differences to evaluate the derivatives, \code{DerivLogf} utilizes \code{Deriv} to build sub functions for each variable in \code{names}.
The same is true for \code{Deriv2Logf}.

\code{Deriv} won't recognize components or parameters accessed by \code{[}, \code{[[} or \code{$} as variables (e.g. \code{theta[["beta1"]]}).
Therefore it's necessary to specify mappings from \code{y} and \code{theta} to the variables in \code{f}.
}
\examples{
library(copula)

## build f
margins = list(alist(pdf=dnorm(y1, beta10 + beta11*x, 1),
                     cdf=pnorm(y1, beta10 + beta11*x, 1)),
               alist(pdf=dnorm(y2, beta20 + beta21*x, 1),
                     cdf=pnorm(y2, beta20 + beta21*x, 1)))
C = claytonCopula()
f = buildf(margins, C)
f

theta = list(alpha=2, beta10=1, beta11=2, beta20=3, beta21=4, x=5)

## build first derivative
n = c('alpha', 'beta10', 'beta11', 'beta20', 'beta21')
yMap = list(y1=1, y2=2)
thetaMap = list(alpha='alpha', beta10='beta10', beta11='beta11',
                               beta20='beta20', beta21='beta21', x='x')
dlogf = DerivLogf(f, n, yMap=yMap, thetaMap=thetaMap)
str(dlogf)

## build reference
margins = function(y, theta) {
    mu = c(theta$beta10 + theta$beta11*theta$x,
           theta$beta20 + theta$beta21*theta$x)
    cbind(dnorm(y, mu, 1), pnorm(y, mu, 1))
}
f2 = buildf(margins, C, 'alpha')
f2

dlogf2 = numDerivLogf(f2)

## evaluate
y = c(11, 22)
m1 = quote( sapply(n, function(i) dlogf(y, theta, i)) )
m2 = quote( sapply(n, function(i) dlogf2(y, theta, i)) )
eval(m1)
eval(m2)

system.time(replicate(50, eval(m1)))
system.time(replicate(50, eval(m2)))

## build second derivative
d2logf = Deriv2Logf(f, n, yMap=yMap, thetaMap=thetaMap)
str(d2logf)

## build reference
d2logf2 = numDeriv2Logf(f2)

## evaluate
m1 = quote( outer(n,n, function(a, b) apply(cbind(a, b), 1,
    function(x) d2logf(y, theta, x[1], x[2]))) )
m2 = quote( outer(n, n, function(a, b) apply(cbind(a, b), 1,
    function(x) d2logf2(y, theta, x[1], x[2]))) )
eval(m1)
eval(m2)

## benchmark
system.time(replicate(50, eval(m1)))
system.time(replicate(5, eval(m2))) * 10
}
\seealso{
\code{\link[Deriv]{Deriv}} in package \pkg{Deriv}, \code{\link{buildf}}, \code{\link{numDerivLogf}}, \code{\link{fisherI}}
}

